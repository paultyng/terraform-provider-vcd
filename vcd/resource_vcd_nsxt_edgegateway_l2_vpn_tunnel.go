package vcd

import (
	"context"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/vmware/go-vcloud-director/v2/types/v56"
)

func resourceVcdNsxtEdgegatewayL2VpnTunnel() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceVcdNsxtEdgegatewayL2VpnTunnelCreate,
		UpdateContext: resourceVcdNsxtEdgegatewayDhcpForwardingUpdate,
		ReadContext:   resourceVcdNsxtEdgegatewayDhcpForwardingRead,
		DeleteContext: resourceVcdNsxtEdgegatewayDhcpForwardingDelete,
		Importer: &schema.ResourceImporter{
			StateContext: resourceVcdNsxtEdgegatewayDhcpForwardingImport,
		},

		Schema: map[string]*schema.Schema{
			"org": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
				Description: "The name of organization to use, optional if defined at provider " +
					"level. Useful when connected as sysadmin working across different organizations",
			},
			"edge_gateway_id": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: "Edge gateway ID for the tunnel",
			},
			"name": {
				Type:         schema.TypeString,
				Required:     true,
				Description:  "Name of the L2 VPN Tunnel session",
				ValidateFunc: validation.IsIPAddress,
			},
			"description": {
				Type:         schema.TypeString,
				Optional:     true,
				Description:  "Description of the L2 VPN Tunnel session",
				ValidateFunc: validation.IsIPAddress,
			},
			"session_mode": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validation.StringInSlice([]string{"CLIENT", "SERVER"}, false),
				Description:  "Mode of the tunnel session, must be CLIENT or SERVER",
			},
			"enabled": {
				Type:        schema.TypeBool,
				Required:    true,
				Description: "Status of the L2 VPN Tunnel session",
			},
			"local_endpoint_ip": {
				Type:         schema.TypeString,
				Required:     true,
				Description:  "Local endpoint IP of the tunnel session, the IP must be sub-allocated to the Edge Gateway",
				ValidateFunc: validation.IsIPAddress,
			},
			"remote_endpoint_ip": {
				Type:     schema.TypeString,
				Required: true,
				Description: "The IP address of the remote endpoint, which corresponds to the device" +
					"on the remote site terminating the VPN tunnel.",
				ValidateFunc: validation.IsIPAddress,
			},
			"tunnel_interface": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				Description: "Network CIDR block over which the session interfaces. Only relevant if " +
					"`session_mode` is set to `SERVER`",
				ValidateFunc: validation.IsCIDR,
			},
			"connector_initiation_mode": {
				Type:     schema.TypeString,
				Optional: true,
				Description: "Connector initation mode of the session describing how a connection is made. " +
					"Needs to be set only if `session_mode` is set to `SERVER`",
				ValidateFunc: validation.StringInSlice([]string{"INITIATOR", "RESPOND_ONLY", "ON_DEMAND"}, false),
			},
			"pre_shared_key": {
				Type:     schema.TypeString,
				Optional: true,
				Description: "Pre-shared key used for authentication, needs to be provided only on creation of" +
					"`SERVER` sessions",
			},
			"peer_code": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				Description: "Base64 encoded string of the full configuration of the tunnel, " +
					"generated by the server-side L2 VPN session. This value contains the encoded pre-shared key " +
					"so it is user's responsibility to secure it. Needs to be provided only on creation of" +
					"`CLIENT` sessions",
			},
			"stretched_networks": {
				Type:     schema.TypeSet,
				Optional: true,
				// DHCP forwarding supports up to 8 IP addresses
				Description: "Org VDC networks that are attached to this L2 VPN tunnel",
				Elem: map[string]*schema.Schema{
					"network_id": {
						Type:        schema.TypeString,
						Required:    true,
						Description: "ID of the Org VDC network",
					},
					"tunnel_id": {
						Type:         schema.TypeInt,
						Optional:     true,
						Computed:     true,
						Description:  "Tunnel ID of the network for the tunnel. Read-only for `SERVER` sessions.",
						ValidateFunc: validation.IntBetween(1, 4093),
					},
				},
			},
		},
	}
}

func resourceVcdNsxtEdgegatewayL2VpnTunnelCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	vcdClient := meta.(*VCDClient)

	unlock, err := vcdClient.lockParentVdcGroupOrEdgeGateway(d)
	if err != nil {
		return diag.Errorf("[L2 VPN Tunnel create] %s", err)
	}

	defer unlock()

	orgName := d.Get("org").(string)
	edgeGatewayId := d.Get("edge_gateway_id").(string)

	nsxtEdge, err := vcdClient.GetNsxtEdgeGatewayById(orgName, edgeGatewayId)
	if err != nil {
		return diag.Errorf("[L2 VPN Tunnel create] error retrieving Edge Gateway: %s", err)
	}
	name := d.Get("name").(string)
	description := d.Get("description").(string)
	sessionMode := d.Get("session_mode").(string)
	enabled := d.Get("enabled").(bool)
	localEndpointIp := d.Get("local_endpoint_ip").(string)
	remoteEndpointIp := d.Get("remote_endpoint_ip").(string)
	tunnelInterface := d.Get("tunnel_interface").(string)
	connectorInitiationMode := d.Get("connector_initiation_mode").(string)
	peerCode := d.Get("peer_code").(string)
	preSharedKey := d.Get("pre_shared_key").(string)
	attachedNetworks := d.Get("attached_networks")
	l2VpnTunnel := &types.NsxtL2VpnTunnel{
		Name:                    name,
		Description:             description,
		SessionMode:             sessionMode,
		Enabled:                 enabled,
		LocalEndpointIp:         localEndpointIp,
		RemoteEndpointIp:        remoteEndpointIp,
		TunnelInterface:         tunnelInterface,
		ConnectorInitiationMode: connectorInitiationMode,
		PeerCode:                peerCode,
		PreSharedKey:            preSharedKey,
		StretchedNetworks:       attachedNetworks.([]types.EdgeL2VpnStretchedNetwork),
	}

	nsxtEdge.CreateL2VpnTunnel(l2VpnTunnel)

	// As there may be warnings in the CreateUpdate function, we need to append them
	// to the read function, as we don't want to exit the program if there is only
	// a warning.
	return resourceVcdNsxtEdgegatewayDhcpForwardingRead(ctx, d, meta)
}
